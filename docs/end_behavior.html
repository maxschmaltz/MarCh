<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>marchie.end_behavior API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>marchie.end_behavior</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#region Imports

import numpy as np
from typing import Tuple

from structure import ChainProperties

#endregion


def _solve_equation_system(coefficient_mat: np.ndarray, solutions: np.ndarray) -&gt; np.ndarray:

    &#39;&#39;&#39;
    ### Solves an equation system with Cramer&#39;s Rule.
    Cramer&#39;s Rule is a method to solve an equation system where
    the number of variables and the number of equations is the same.
    In the method, the matrix of the coefficients of the variables
    and the solutions of the equations are needed.

    Parameters
    ----------
    coefficient_mat : `numpy.ndarray` of shape (`n_equations`, `n_coefficients`), `n_equations` = `n_coefficients`
        matrix of the coefficients of the variables

    solutions : `numpy.ndarray` of shape (`n_equations`, )
        vector of solutions of the equations

    Returns
    -------
    pi : `numpy.ndarray` of shape (`n_equations`, )
        vector of variable values
    &#39;&#39;&#39;

    _, n_coefficients = coefficient_mat.shape
    pi = np.zeros((n_coefficients)) # pi is the vector of variables
    coef_delta = np.linalg.det(coefficient_mat)
    for i in range(n_coefficients):
        sub_mat = coefficient_mat.copy()
        sub_mat[:, i] = solutions.T
        delta = np.linalg.det(sub_mat)
        pi[i] = delta / coef_delta
    return pi


#region End Behavior

class EndBehavior:

    &#39;&#39;&#39;
    ### Base class to determine end behavior of a Markov Chain.
    End behavior of a Markov chain can be described with 3 properties:

    * end state distribution vector: what are the probabilities of
    the system to be in each state in a very large (limits to infinity) number of steps;
    accessible in `end_state_distr` property

    * end transition matrix: what are the probabilities of
    the transitions in a very large (limits to infinity) number of steps;
    accessible in `end_trans_mat` property

    * end time percentage: how much time the system will spend in each of the states
    during a very long (limits to infinity) period of time;
    accessible in `time_percentage` property

    Note that only regular chains converge to those probabilities strongly;
    cyclic and mixed chains show different empirical end behavior.

    You may refer to the demo notebook (&#34;./demo.ipynb&#34;) to find out how the
    end behavior for different types of chains are calculated.

    Parameters
    ----------
    chain : `MarChie`
        an instantiated `MarChie` object to calculate the end behavior of
    &#39;&#39;&#39;

    end_state_distr: np.ndarray
    &#39;&#39;&#39;
    ### End state distribution vector.
    Calculates what are the probabilities of
    the system to be in each state in a very large (limits to infinity) number of steps.

    Returns
    ----------
    end_state_distr : `numpy.ndarray` of shape (`chain.n_states`, )
        end state distribution vector
    &#39;&#39;&#39;

    end_trans_mat: np.ndarray
    &#39;&#39;&#39;
    ### End transition matrix.
    Calculates what are the probabilities of
    the transitions in a very large (limits to infinity) number of steps.

    Returns
    ----------
    end_trans_mat : `numpy.ndarray` of shape (`chain.n_states`, `chain.n_states`)
        end transition matrix
    &#39;&#39;&#39;

    time_percentage: np.ndarray
    &#39;&#39;&#39;
    # End time percentage.
    Calculates how much time the system will spend in each of the states
    during a very long (limits to infinity) period of time.

    Returns
    -------
    time_percentage : `numpy.ndarray` of shape (`chain.n_states`, )
        vector of percentages (0-100) for each state in canonical numbering
    &#39;&#39;&#39;

    def __init__(self, chain) -&gt; None:
        self.chain = chain
        self.end_state_distr = self._end_state_distr()
        self.end_trans_mat = self._end_trans_mat()  
        self.time_percentage = self._time_percentage()

    def equation_system(self, matrix: np.ndarray=None) -&gt; Tuple[np.ndarray]:

        &#39;&#39;&#39;
        ### Converts a square matrix into an equation system.

        Parameters
        ----------
        matrix : `numpy.ndarray` of shape (`n`, `n`), optional, defaults to `None`
            the matrix to turn into an equation system; if `None`,
            convert the transition matrix of `chain`

        Returns
        -------
        coefficient_matrix : `numpy.ndarray` of shape (`n`, `n`)
            matrix of coefficients of the equation system
        
        answers : `numpy.ndarray` of shape (`n`, )
            vector of answers of the equation system

        Raises
        ------
        AssertionError
            if `matrix` is not square
        &#39;&#39;&#39;

        ## Below are examples for a better understanding why the system is built this way.
        ## Imagine we have 3 states, then the transition matrix looks like:
        ##   /   c00     c01     c02   \
        ##   |   c10     c11     c12   |
        ##   \   c20     c21     c22   /
        ## 
        ## If a chain fragment P (e.g. standing for an equivalent class or the whole matrix) 
        ## limits to some end matrix (fragment) Π, that end fragment Π can be represented
        ## as a matrix with equal rows π = (π0, π1, ...), in out case:
        ##   /   π0      π1      π2   \
        ##   |   π0      π1      π2   |
        ##   \   π0      π1      π2   /
        ## 
        ## That actually means that in the end behavior, the following statement will be fair:
        ## πP = π
        ##
        ## It is fair as the end fragment becomes stationary at its end.
        ## If we rewrite the equation, we get:
        ##                          /   c00     c01     c02   \
        ##   (π0      π1      π2)   |   c10     c11     c12   | = (π0      π1      π2)
        ##                          \   c20     c21     c22   /
        ##
        ## Now we can actually multiply matrices and get the equation system:
        ##   |   c00π0 + c10π1 + c20π2 = π0
        ##   |   c01π0 + c11π1 + c21π2 = π1
        ##   |   c02π0 + c12π1 + c22π2 = π2
        ##
        ## We can subtract the answers:
        ##   |   (c00 - 1)π0 + c10π1 + c20π2 = 0
        ##   |   c01π0 + (c11 - 1)π1 + c21π2 = 0
        ##   |   c02π0 + c12π1 + (c22 - 1)π2 = 0
        ##
        ## coefficient matrix looks like this then:
        ##   / c00 - 1   c10     c20   \
        ##   |   c01   c11 - 1   c21   |
        ##   \   c02     c12   c22 - 1 /
        ##
        ## As one can see, the coefficient matrix is basically just the transposed
        ## transition matrix, where the values at the diagonal are subtracted by 1
        ## (just because we subtracted 1 * πi from each equation).
        ## Now the only problem there might be is that the coefficient matrix is nondegenerate
        ## (the determiner equals 0), hence, we will not be able to solve it with Creamer&#39;s rule.
        ## To avoid that, we might substitute an equation in the system with
        ## the π vector (it&#39;s stochastic, so we know for sure that sum(π) equals 1):
        ##   |   π0    + π1    +   2         = 1
        ##   |   c01π0 + (c11 - 1)π1 + c21π2 = 0
        ##   |   c02π0 + c12π1 + (c22 - 1)π2 = 0
        ##
        ## In the end we have a coefficient matrix that equals the transposed 
        ## transition matrix where the values at the diagonal are subtracted by 1
        ## and some row is substituted by ones (since it&#39;s 1 * πi):
        ##   /    1       1        1   \
        ##   |   c01   c11 - 1   c21   |
        ##   \   c02     c12   c22 - 1 /

        if matrix is None: matrix = self.chain.trans_mat.canonical
        n_states, n = matrix.shape

        assert n_states == n, &#39;Only square matrices are supported.&#39;

        coefficient_matrix = np.zeros(matrix.shape)
        coefficient_matrix = matrix.T # transpose to get coefficients
        for i in range(n_states): coefficient_matrix[i, i] -= 1 # subtract answers
        coefficient_matrix[0] = np.ones((n_states)) # substitute an equation (say, the first)
        answers = np.zeros((n_states)); answers[0] = 1 # update answers
        return coefficient_matrix, answers

    def _end_state_distr(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end state distribution vector.
        Calculates what are the probabilities of
        the system to be in each state in a very large (limits to infinity) number of steps.

        Raises
        ------
        NotImplementedError
            if trying to instantiate the base class 
        &#39;&#39;&#39;
        
        raise NotImplementedError(&#39;You should define end state distribution vector in your derived class.&#39;)

    def _end_trans_mat(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end transition matrix.
        Calculates what are the probabilities of
        the transitions in a very large (limits to infinity) number of steps.

        Raises
        ------
        NotImplementedError
            if trying to instantiate the base class 
        &#39;&#39;&#39;

        raise NotImplementedError(&#39;You should define end transition probability matrix in your derived class.&#39;)

    def _time_percentage(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end time percentage.
        Calculates how much time the system will spend in each of the states
        during a very long (limits to infinity) period of time.

        Returns
        -------
        time_percentage : `numpy.ndarray` of shape (`chain.n_states`, )
            vector of percentages (0-100) for each state in canonical numbering
        &#39;&#39;&#39;
        
        time_percentage = self.end_state_distr * 100
        return time_percentage
    

class ErgodicChainEndBehavior(EndBehavior):

    &#39;&#39;&#39;
    ### Class to determine end behavior of an ergodic (irreducible) Markov Chain.
    An ergodic (irreducible) Markov Chain has no inessential states and 
    a single equivalency class (and thus coincide with it).

    Refer to the base class `EndBehavior` for parameters and description 
    of what the end behavior is.
    &#39;&#39;&#39;

    def _end_state_distr(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end state distribution vector.
        Calculates what are the probabilities of
        the system to be in each state in a very large (limits to infinity) number of steps.

        Returns
        ----------
        end_state_distr : `numpy.ndarray` of shape (`chain.n_states`, )
            end state distribution vector
        &#39;&#39;&#39;

        end_state_distr = _solve_equation_system(
            *self.equation_system()
        )
        return end_state_distr

    def _end_trans_mat(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end transition matrix.
        Calculates what are the probabilities of
        the transitions in a very large (limits to infinity) number of steps.

        Returns
        ----------
        end_trans_mat : `numpy.ndarray` of shape (`chain.n_states`, `chain.n_states`)
            end transition matrix
        &#39;&#39;&#39;

        end_trans_mat = self.chain._zero_mask
        end_trans_mat[:] = self.end_state_distr
        return end_trans_mat


class MonoergodicChainEndBehavior(EndBehavior):

    &#39;&#39;&#39;
    ### Class to determine end behavior of a monoergodic Markov Chain.
    A monoergodic Markov Chain has \(1\) or more inessential states and 
    a single equivalency class.

    Refer to the base class `EndBehavior` for parameters and description 
    of what the end behavior is.
    &#39;&#39;&#39;

    def _end_state_distr(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end state distribution vector.
        Calculates what are the probabilities of
        the system to be in each state in a very large (limits to infinity) number of steps.

        Returns
        ----------
        end_state_distr : `numpy.ndarray` of shape (`chain.n_states`, )
            end state distribution vector
        &#39;&#39;&#39;

        essential_submat = self.chain.trans_mat.canonical[
            # left upper corner given the canonical numbering
            0: self.chain.n_essential_states,
            0: self.chain.n_essential_states
        ]
        essential_end_state_distr = _solve_equation_system(
            *self.equation_system(essential_submat)
        )
        end_zeros = np.zeros((self.chain.n_inessential_states))
        end_state_distr = np.concatenate((essential_end_state_distr, end_zeros), axis=0)
        return end_state_distr

    def _end_trans_mat(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end transition matrix.
        Calculates what are the probabilities of
        the transitions in a very large (limits to infinity) number of steps.

        Returns
        ----------
        end_trans_mat : `numpy.ndarray` of shape (`chain.n_states`, `chain.n_states`)
            end transition matrix
        &#39;&#39;&#39;

        end_trans_mat = self.chain._zero_mask
        end_trans_mat[:] = self.end_state_distr
        return end_trans_mat


class PolyergodicChainEndBehavior(EndBehavior):

    &#39;&#39;&#39;
    ### Class to determine end behavior of a polyergodic Markov Chain.
    A polyergodic Markov Chain has \(1\) or more inessential states and 
    several (\(2\) or more) equivalency classes.

    Refer to the base class `EndBehavior` for parameters and description 
    of what the end behavior is.
    &#39;&#39;&#39;
  
    def __init__(self, chain) -&gt; None:
        self.chain = chain
        self.end_trans_mat = self._end_trans_mat()  
        self.end_state_distr = self._end_state_distr()
        self.time_percentage = None

    def _end_state_distr(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end state distribution vector.
        Calculates what are the probabilities of
        the system to be in each state in a very large (limits to infinity) number of steps.

        Returns
        ----------
        end_state_distr : `numpy.ndarray` of shape (`chain.n_states`, )
            end state distribution vector
        &#39;&#39;&#39;

        end_state_distr = np.matmul(
            self.chain.init_distr,
            self.end_trans_mat
        )
        return end_state_distr

    def _end_trans_mat(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end transition matrix.
        Calculates what are the probabilities of
        the transitions in a very large (limits to infinity) number of steps.

        Returns
        ----------
        end_trans_mat : `numpy.ndarray` of shape (`chain.n_states`, `chain.n_states`)
            end transition matrix
        &#39;&#39;&#39;

        c = 0

        # essential submatrix `Пe`
        essential_submat = np.zeros((self.chain.n_essential_states, self.chain.n_states))
        essential_vectors = []
        for i, eq_class in enumerate(self.chain.structure.equivalency_classes):

            # transitions in each class `t` are described by its submatrix `Tt`
            begin, end = eq_class.canonical_states[0], eq_class.canonical_states[-1]
            class_mat = self.chain.trans_mat.canonical[
                begin: end + 1,
                begin: end + 1
            ]

            # each row is a vector of `π` form `(0, ..., π_, ..., 0)`,
            # `π_` is a subvector such that `π_ x Tt = π_`;
            # here we find `π_`
            class_vec = _solve_equation_system(
                *self.equation_system(class_mat)
            )
            # number of zeros on the left from `π_`
            n_zeros_left = sum([
                len(prev_eq_class) 
                for prev_eq_class in self.chain.structure.equivalency_classes[:i]
            ])
            # number of zeros on the right from `π_`
            n_zeros_right = sum([
                len(next_eq_class) 
                for next_eq_class in self.chain.structure.equivalency_classes[i + 1:]
            ]) + self.chain.n_inessential_states

            # finally `π`
            class_vec = np.concatenate((
                np.zeros((n_zeros_left)),
                class_vec,
                np.zeros((n_zeros_right))
            ), axis=0)

            # put in `Пe`; store `π`
            for _ in range(len(eq_class)): essential_submat[c] = class_vec; c += 1;
            essential_vectors.append(class_vec)


        # inessential to essential submatrix `B`
        absorbing_trans_mat = self.chain.trans_mat.canonical.copy()
        states_to_delete = []
        for eq_class in self.chain.structure.equivalency_classes:
            # leave the first state of each class
            states_to_delete += eq_class.canonical_states[1:]
            # substitute the probabilities with a single sum of them
            absorbing_trans_mat[:, eq_class.canonical_states[0]] = (absorbing_trans_mat[:, eq_class.canonical_states]).sum(axis=1)
        # delete remaining states
        absorbing_trans_mat = np.delete(absorbing_trans_mat, states_to_delete, axis=0)
        absorbing_trans_mat = np.delete(absorbing_trans_mat, states_to_delete, axis=1)

        absorbing_n_states, _ = absorbing_trans_mat.shape
        # each equivalency class we substituted with a single state,
        # which means in `absorbing_trans_mat` the number of essential states
        # equals the number of equivalency classes in the original matrix
        absorbing_identity_mat = np.identity(self.chain.n_inessential_states)
        absorbing_inessential_submat = absorbing_trans_mat[
            # right lower corner given the canonical numbering
            self.chain.n_equivalency_classes: absorbing_n_states,
            self.chain.n_equivalency_classes: absorbing_n_states
        ]
        absorbing_end_inessential_submat = np.linalg.inv(absorbing_identity_mat - absorbing_inessential_submat)
        absorbing_inessential_to_essential_submat = absorbing_trans_mat[
            # left lower corner given the canonical numbering
            self.chain.n_equivalency_classes: absorbing_n_states,
            0: self.chain.n_equivalency_classes
        ]
        end_inessential_to_essential_submat = np.matmul(
            absorbing_end_inessential_submat,
            absorbing_inessential_to_essential_submat
        )


        # inessential submatrix `Пie`
        inessential_submat = np.zeros((self.chain.n_inessential_states, self.chain.n_states))
        for i, iness_row in enumerate(inessential_submat):
            for t, ess_row in enumerate(essential_vectors):
                iness_row += end_inessential_to_essential_submat[i, t] * ess_row


        end_trans_mat = np.concatenate((essential_submat, inessential_submat), axis=0)
        return end_trans_mat

    def _time_percentage(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end time percentage.
        Calculates how much time the system will spend in each of the states
        during a very long (limits to infinity) period of time.
        NB! Not supported for polyergodic chains.

        Raises
        -------
        NotImplementedError
            when trying to calculate end time percentage for a polyergodic Markov Chain
        &#39;&#39;&#39;

        raise NotImplementedError(
            &#39;Percentages of time for each state are not supposed to be calculated for polyergodic chains.&#39;
        )
  

class PolyergodicAbsorbingChainEndBehavior(PolyergodicChainEndBehavior):

    &#39;&#39;&#39;
    ### Class to determine end behavior of a polyergodic absorbing Markov Chain.
    A polyergodic absorbing Markov Chain has 1 or more inessential states and 
    several (2 or more) equivalency classes, each of which is absorbing.

    Refer to the base class `EndBehavior` for parameters and description 
    of what the end behavior is.
    &#39;&#39;&#39;

    def _end_trans_mat(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end transition matrix.
        Calculates what are the probabilities of
        the transitions in a very large (limits to infinity) number of steps.

        Returns
        ----------
        end_trans_mat : `numpy.ndarray` of shape (`chain.n_states`, `chain.n_states`)
            end transition matrix
        &#39;&#39;&#39;

        # essential submatrix `T`
        end_essential_submat = np.identity(self.chain.n_essential_states)

        # inessential to essential submatrix `B`
        identity_mat = np.identity(self.chain.n_inessential_states)
        inessential_submat = self.chain.trans_mat.canonical[
            # right lower corner given the canonical numbering
            self.chain.n_essential_states: self.chain.n_states,
            self.chain.n_essential_states: self.chain.n_states
        ]
        end_inessential_submat = np.linalg.inv(identity_mat - inessential_submat)
        inessential_to_essential_submat = self.chain.trans_mat.canonical[
            # left lower corner given the canonical numbering
            self.chain.n_essential_states: self.chain.n_states,
            0: self.chain.n_essential_states
        ]
        end_inessential_to_essential_submat = np.matmul(end_inessential_submat, inessential_to_essential_submat)

        end_trans_mat = self.chain._zero_mask
        end_trans_mat[
            # left upper corner given the canonical numbering
            0: self.chain.n_essential_states,
            0: self.chain.n_essential_states
        ] = end_essential_submat
        end_trans_mat[
            # left lower corner given the canonical numbering
            self.chain.n_essential_states: self.chain.n_states,
            0: self.chain.n_essential_states
        ] = end_inessential_to_essential_submat

        return end_trans_mat
    
#endregion</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="marchie.end_behavior.EndBehavior"><code class="flex name class">
<span>class <span class="ident">EndBehavior</span></span>
<span>(</span><span>chain)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="base-class-to-determine-end-behavior-of-a-markov-chain">Base class to determine end behavior of a Markov Chain.</h3>
<p>End behavior of a Markov chain can be described with 3 properties:</p>
<ul>
<li>
<p>end state distribution vector: what are the probabilities of
the system to be in each state in a very large (limits to infinity) number of steps;
accessible in <code>end_state_distr</code> property</p>
</li>
<li>
<p>end transition matrix: what are the probabilities of
the transitions in a very large (limits to infinity) number of steps;
accessible in <code>end_trans_mat</code> property</p>
</li>
<li>
<p>end time percentage: how much time the system will spend in each of the states
during a very long (limits to infinity) period of time;
accessible in <code>time_percentage</code> property</p>
</li>
</ul>
<p>Note that only regular chains converge to those probabilities strongly;
cyclic and mixed chains show different empirical end behavior.</p>
<p>You may refer to the demo notebook ("./demo.ipynb") to find out how the
end behavior for different types of chains are calculated.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chain</code></strong> :&ensp;<code><a title="MarChie" href="../API_reference.html">MarChie</a></code></dt>
<dd>an instantiated <code><a title="MarChie" href="../API_reference.html">MarChie</a></code> object to calculate the end behavior of</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EndBehavior:

    &#39;&#39;&#39;
    ### Base class to determine end behavior of a Markov Chain.
    End behavior of a Markov chain can be described with 3 properties:

    * end state distribution vector: what are the probabilities of
    the system to be in each state in a very large (limits to infinity) number of steps;
    accessible in `end_state_distr` property

    * end transition matrix: what are the probabilities of
    the transitions in a very large (limits to infinity) number of steps;
    accessible in `end_trans_mat` property

    * end time percentage: how much time the system will spend in each of the states
    during a very long (limits to infinity) period of time;
    accessible in `time_percentage` property

    Note that only regular chains converge to those probabilities strongly;
    cyclic and mixed chains show different empirical end behavior.

    You may refer to the demo notebook (&#34;./demo.ipynb&#34;) to find out how the
    end behavior for different types of chains are calculated.

    Parameters
    ----------
    chain : `MarChie`
        an instantiated `MarChie` object to calculate the end behavior of
    &#39;&#39;&#39;

    end_state_distr: np.ndarray
    &#39;&#39;&#39;
    ### End state distribution vector.
    Calculates what are the probabilities of
    the system to be in each state in a very large (limits to infinity) number of steps.

    Returns
    ----------
    end_state_distr : `numpy.ndarray` of shape (`chain.n_states`, )
        end state distribution vector
    &#39;&#39;&#39;

    end_trans_mat: np.ndarray
    &#39;&#39;&#39;
    ### End transition matrix.
    Calculates what are the probabilities of
    the transitions in a very large (limits to infinity) number of steps.

    Returns
    ----------
    end_trans_mat : `numpy.ndarray` of shape (`chain.n_states`, `chain.n_states`)
        end transition matrix
    &#39;&#39;&#39;

    time_percentage: np.ndarray
    &#39;&#39;&#39;
    # End time percentage.
    Calculates how much time the system will spend in each of the states
    during a very long (limits to infinity) period of time.

    Returns
    -------
    time_percentage : `numpy.ndarray` of shape (`chain.n_states`, )
        vector of percentages (0-100) for each state in canonical numbering
    &#39;&#39;&#39;

    def __init__(self, chain) -&gt; None:
        self.chain = chain
        self.end_state_distr = self._end_state_distr()
        self.end_trans_mat = self._end_trans_mat()  
        self.time_percentage = self._time_percentage()

    def equation_system(self, matrix: np.ndarray=None) -&gt; Tuple[np.ndarray]:

        &#39;&#39;&#39;
        ### Converts a square matrix into an equation system.

        Parameters
        ----------
        matrix : `numpy.ndarray` of shape (`n`, `n`), optional, defaults to `None`
            the matrix to turn into an equation system; if `None`,
            convert the transition matrix of `chain`

        Returns
        -------
        coefficient_matrix : `numpy.ndarray` of shape (`n`, `n`)
            matrix of coefficients of the equation system
        
        answers : `numpy.ndarray` of shape (`n`, )
            vector of answers of the equation system

        Raises
        ------
        AssertionError
            if `matrix` is not square
        &#39;&#39;&#39;

        ## Below are examples for a better understanding why the system is built this way.
        ## Imagine we have 3 states, then the transition matrix looks like:
        ##   /   c00     c01     c02   \
        ##   |   c10     c11     c12   |
        ##   \   c20     c21     c22   /
        ## 
        ## If a chain fragment P (e.g. standing for an equivalent class or the whole matrix) 
        ## limits to some end matrix (fragment) Π, that end fragment Π can be represented
        ## as a matrix with equal rows π = (π0, π1, ...), in out case:
        ##   /   π0      π1      π2   \
        ##   |   π0      π1      π2   |
        ##   \   π0      π1      π2   /
        ## 
        ## That actually means that in the end behavior, the following statement will be fair:
        ## πP = π
        ##
        ## It is fair as the end fragment becomes stationary at its end.
        ## If we rewrite the equation, we get:
        ##                          /   c00     c01     c02   \
        ##   (π0      π1      π2)   |   c10     c11     c12   | = (π0      π1      π2)
        ##                          \   c20     c21     c22   /
        ##
        ## Now we can actually multiply matrices and get the equation system:
        ##   |   c00π0 + c10π1 + c20π2 = π0
        ##   |   c01π0 + c11π1 + c21π2 = π1
        ##   |   c02π0 + c12π1 + c22π2 = π2
        ##
        ## We can subtract the answers:
        ##   |   (c00 - 1)π0 + c10π1 + c20π2 = 0
        ##   |   c01π0 + (c11 - 1)π1 + c21π2 = 0
        ##   |   c02π0 + c12π1 + (c22 - 1)π2 = 0
        ##
        ## coefficient matrix looks like this then:
        ##   / c00 - 1   c10     c20   \
        ##   |   c01   c11 - 1   c21   |
        ##   \   c02     c12   c22 - 1 /
        ##
        ## As one can see, the coefficient matrix is basically just the transposed
        ## transition matrix, where the values at the diagonal are subtracted by 1
        ## (just because we subtracted 1 * πi from each equation).
        ## Now the only problem there might be is that the coefficient matrix is nondegenerate
        ## (the determiner equals 0), hence, we will not be able to solve it with Creamer&#39;s rule.
        ## To avoid that, we might substitute an equation in the system with
        ## the π vector (it&#39;s stochastic, so we know for sure that sum(π) equals 1):
        ##   |   π0    + π1    +   2         = 1
        ##   |   c01π0 + (c11 - 1)π1 + c21π2 = 0
        ##   |   c02π0 + c12π1 + (c22 - 1)π2 = 0
        ##
        ## In the end we have a coefficient matrix that equals the transposed 
        ## transition matrix where the values at the diagonal are subtracted by 1
        ## and some row is substituted by ones (since it&#39;s 1 * πi):
        ##   /    1       1        1   \
        ##   |   c01   c11 - 1   c21   |
        ##   \   c02     c12   c22 - 1 /

        if matrix is None: matrix = self.chain.trans_mat.canonical
        n_states, n = matrix.shape

        assert n_states == n, &#39;Only square matrices are supported.&#39;

        coefficient_matrix = np.zeros(matrix.shape)
        coefficient_matrix = matrix.T # transpose to get coefficients
        for i in range(n_states): coefficient_matrix[i, i] -= 1 # subtract answers
        coefficient_matrix[0] = np.ones((n_states)) # substitute an equation (say, the first)
        answers = np.zeros((n_states)); answers[0] = 1 # update answers
        return coefficient_matrix, answers

    def _end_state_distr(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end state distribution vector.
        Calculates what are the probabilities of
        the system to be in each state in a very large (limits to infinity) number of steps.

        Raises
        ------
        NotImplementedError
            if trying to instantiate the base class 
        &#39;&#39;&#39;
        
        raise NotImplementedError(&#39;You should define end state distribution vector in your derived class.&#39;)

    def _end_trans_mat(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end transition matrix.
        Calculates what are the probabilities of
        the transitions in a very large (limits to infinity) number of steps.

        Raises
        ------
        NotImplementedError
            if trying to instantiate the base class 
        &#39;&#39;&#39;

        raise NotImplementedError(&#39;You should define end transition probability matrix in your derived class.&#39;)

    def _time_percentage(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end time percentage.
        Calculates how much time the system will spend in each of the states
        during a very long (limits to infinity) period of time.

        Returns
        -------
        time_percentage : `numpy.ndarray` of shape (`chain.n_states`, )
            vector of percentages (0-100) for each state in canonical numbering
        &#39;&#39;&#39;
        
        time_percentage = self.end_state_distr * 100
        return time_percentage</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="marchie.end_behavior.ErgodicChainEndBehavior" href="#marchie.end_behavior.ErgodicChainEndBehavior">ErgodicChainEndBehavior</a></li>
<li><a title="marchie.end_behavior.MonoergodicChainEndBehavior" href="#marchie.end_behavior.MonoergodicChainEndBehavior">MonoergodicChainEndBehavior</a></li>
<li><a title="marchie.end_behavior.PolyergodicChainEndBehavior" href="#marchie.end_behavior.PolyergodicChainEndBehavior">PolyergodicChainEndBehavior</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="marchie.end_behavior.EndBehavior.end_state_distr"><code class="name">var <span class="ident">end_state_distr</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><h3 id="end-state-distribution-vector">End state distribution vector.</h3>
<p>Calculates what are the probabilities of
the system to be in each state in a very large (limits to infinity) number of steps.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>end_state_distr</code></strong> :&ensp;<code>numpy.ndarray</code> of shape (<code>chain.n_states</code>, )</dt>
<dd>end state distribution vector</dd>
</dl></div>
</dd>
<dt id="marchie.end_behavior.EndBehavior.end_trans_mat"><code class="name">var <span class="ident">end_trans_mat</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><h3 id="end-transition-matrix">End transition matrix.</h3>
<p>Calculates what are the probabilities of
the transitions in a very large (limits to infinity) number of steps.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>end_trans_mat</code></strong> :&ensp;<code>numpy.ndarray</code> of shape (<code>chain.n_states</code>, <code>chain.n_states</code>)</dt>
<dd>end transition matrix</dd>
</dl></div>
</dd>
<dt id="marchie.end_behavior.EndBehavior.time_percentage"><code class="name">var <span class="ident">time_percentage</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><h1 id="end-time-percentage">End time percentage.</h1>
<p>Calculates how much time the system will spend in each of the states
during a very long (limits to infinity) period of time.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>time_percentage</code></strong> :&ensp;<code>numpy.ndarray</code> of shape (<code>chain.n_states</code>, )</dt>
<dd>vector of percentages <span><span class="MathJax_Preview"></span><script type="math/tex">(0 - 100)</script></span> for each state in canonical numbering</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="marchie.end_behavior.EndBehavior.equation_system"><code class="name flex">
<span>def <span class="ident">equation_system</span></span>(<span>self, matrix: numpy.ndarray = None) ‑> Tuple[numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><h3 id="converts-a-square-matrix-into-an-equation-system">Converts a square matrix into an equation system.</h3>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>matrix</code></strong> :&ensp;<code>numpy.ndarray</code> of shape (<code>n</code>, <code>n</code>), optional, defaults to <code>None</code></dt>
<dd>the matrix to turn into an equation system; if <code>None</code>,
convert the transition matrix of <code>chain</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>coefficient_matrix</code></strong> :&ensp;<code>numpy.ndarray</code> of shape (<code>n</code>, <code>n</code>)</dt>
<dd>matrix of coefficients of the equation system</dd>
<dt><strong><code>answers</code></strong> :&ensp;<code>numpy.ndarray</code> of shape (<code>n</code>, )</dt>
<dd>vector of answers of the equation system</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AssertionError</code></dt>
<dd>if <code>matrix</code> is not square</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equation_system(self, matrix: np.ndarray=None) -&gt; Tuple[np.ndarray]:

    &#39;&#39;&#39;
    ### Converts a square matrix into an equation system.

    Parameters
    ----------
    matrix : `numpy.ndarray` of shape (`n`, `n`), optional, defaults to `None`
        the matrix to turn into an equation system; if `None`,
        convert the transition matrix of `chain`

    Returns
    -------
    coefficient_matrix : `numpy.ndarray` of shape (`n`, `n`)
        matrix of coefficients of the equation system
    
    answers : `numpy.ndarray` of shape (`n`, )
        vector of answers of the equation system

    Raises
    ------
    AssertionError
        if `matrix` is not square
    &#39;&#39;&#39;

    ## Below are examples for a better understanding why the system is built this way.
    ## Imagine we have 3 states, then the transition matrix looks like:
    ##   /   c00     c01     c02   \
    ##   |   c10     c11     c12   |
    ##   \   c20     c21     c22   /
    ## 
    ## If a chain fragment P (e.g. standing for an equivalent class or the whole matrix) 
    ## limits to some end matrix (fragment) Π, that end fragment Π can be represented
    ## as a matrix with equal rows π = (π0, π1, ...), in out case:
    ##   /   π0      π1      π2   \
    ##   |   π0      π1      π2   |
    ##   \   π0      π1      π2   /
    ## 
    ## That actually means that in the end behavior, the following statement will be fair:
    ## πP = π
    ##
    ## It is fair as the end fragment becomes stationary at its end.
    ## If we rewrite the equation, we get:
    ##                          /   c00     c01     c02   \
    ##   (π0      π1      π2)   |   c10     c11     c12   | = (π0      π1      π2)
    ##                          \   c20     c21     c22   /
    ##
    ## Now we can actually multiply matrices and get the equation system:
    ##   |   c00π0 + c10π1 + c20π2 = π0
    ##   |   c01π0 + c11π1 + c21π2 = π1
    ##   |   c02π0 + c12π1 + c22π2 = π2
    ##
    ## We can subtract the answers:
    ##   |   (c00 - 1)π0 + c10π1 + c20π2 = 0
    ##   |   c01π0 + (c11 - 1)π1 + c21π2 = 0
    ##   |   c02π0 + c12π1 + (c22 - 1)π2 = 0
    ##
    ## coefficient matrix looks like this then:
    ##   / c00 - 1   c10     c20   \
    ##   |   c01   c11 - 1   c21   |
    ##   \   c02     c12   c22 - 1 /
    ##
    ## As one can see, the coefficient matrix is basically just the transposed
    ## transition matrix, where the values at the diagonal are subtracted by 1
    ## (just because we subtracted 1 * πi from each equation).
    ## Now the only problem there might be is that the coefficient matrix is nondegenerate
    ## (the determiner equals 0), hence, we will not be able to solve it with Creamer&#39;s rule.
    ## To avoid that, we might substitute an equation in the system with
    ## the π vector (it&#39;s stochastic, so we know for sure that sum(π) equals 1):
    ##   |   π0    + π1    +   2         = 1
    ##   |   c01π0 + (c11 - 1)π1 + c21π2 = 0
    ##   |   c02π0 + c12π1 + (c22 - 1)π2 = 0
    ##
    ## In the end we have a coefficient matrix that equals the transposed 
    ## transition matrix where the values at the diagonal are subtracted by 1
    ## and some row is substituted by ones (since it&#39;s 1 * πi):
    ##   /    1       1        1   \
    ##   |   c01   c11 - 1   c21   |
    ##   \   c02     c12   c22 - 1 /

    if matrix is None: matrix = self.chain.trans_mat.canonical
    n_states, n = matrix.shape

    assert n_states == n, &#39;Only square matrices are supported.&#39;

    coefficient_matrix = np.zeros(matrix.shape)
    coefficient_matrix = matrix.T # transpose to get coefficients
    for i in range(n_states): coefficient_matrix[i, i] -= 1 # subtract answers
    coefficient_matrix[0] = np.ones((n_states)) # substitute an equation (say, the first)
    answers = np.zeros((n_states)); answers[0] = 1 # update answers
    return coefficient_matrix, answers</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="marchie.end_behavior.ErgodicChainEndBehavior"><code class="flex name class">
<span>class <span class="ident">ErgodicChainEndBehavior</span></span>
<span>(</span><span>chain)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="class-to-determine-end-behavior-of-an-ergodic-irreducible-markov-chain">Class to determine end behavior of an ergodic (irreducible) Markov Chain.</h3>
<p>An ergodic (irreducible) Markov Chain has no inessential states and
a single equivalency class (and thus coincide with it).</p>
<p>Refer to the base class <code><a title="marchie.end_behavior.EndBehavior" href="#marchie.end_behavior.EndBehavior">EndBehavior</a></code> for parameters and description
of what the end behavior is.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ErgodicChainEndBehavior(EndBehavior):

    &#39;&#39;&#39;
    ### Class to determine end behavior of an ergodic (irreducible) Markov Chain.
    An ergodic (irreducible) Markov Chain has no inessential states and 
    a single equivalency class (and thus coincide with it).

    Refer to the base class `EndBehavior` for parameters and description 
    of what the end behavior is.
    &#39;&#39;&#39;

    def _end_state_distr(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end state distribution vector.
        Calculates what are the probabilities of
        the system to be in each state in a very large (limits to infinity) number of steps.

        Returns
        ----------
        end_state_distr : `numpy.ndarray` of shape (`chain.n_states`, )
            end state distribution vector
        &#39;&#39;&#39;

        end_state_distr = _solve_equation_system(
            *self.equation_system()
        )
        return end_state_distr

    def _end_trans_mat(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end transition matrix.
        Calculates what are the probabilities of
        the transitions in a very large (limits to infinity) number of steps.

        Returns
        ----------
        end_trans_mat : `numpy.ndarray` of shape (`chain.n_states`, `chain.n_states`)
            end transition matrix
        &#39;&#39;&#39;

        end_trans_mat = self.chain._zero_mask
        end_trans_mat[:] = self.end_state_distr
        return end_trans_mat</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="marchie.end_behavior.EndBehavior" href="#marchie.end_behavior.EndBehavior">EndBehavior</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="marchie.end_behavior.EndBehavior" href="#marchie.end_behavior.EndBehavior">EndBehavior</a></b></code>:
<ul class="hlist">
<li><code><a title="marchie.end_behavior.EndBehavior.end_state_distr" href="#marchie.end_behavior.EndBehavior.end_state_distr">end_state_distr</a></code></li>
<li><code><a title="marchie.end_behavior.EndBehavior.end_trans_mat" href="#marchie.end_behavior.EndBehavior.end_trans_mat">end_trans_mat</a></code></li>
<li><code><a title="marchie.end_behavior.EndBehavior.equation_system" href="#marchie.end_behavior.EndBehavior.equation_system">equation_system</a></code></li>
<li><code><a title="marchie.end_behavior.EndBehavior.time_percentage" href="#marchie.end_behavior.EndBehavior.time_percentage">time_percentage</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="marchie.end_behavior.MonoergodicChainEndBehavior"><code class="flex name class">
<span>class <span class="ident">MonoergodicChainEndBehavior</span></span>
<span>(</span><span>chain)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="class-to-determine-end-behavior-of-a-monoergodic-markov-chain">Class to determine end behavior of a monoergodic Markov Chain.</h3>
<p>A monoergodic Markov Chain has <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> or more inessential states and
a single equivalency class.</p>
<p>Refer to the base class <code><a title="marchie.end_behavior.EndBehavior" href="#marchie.end_behavior.EndBehavior">EndBehavior</a></code> for parameters and description
of what the end behavior is.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MonoergodicChainEndBehavior(EndBehavior):

    &#39;&#39;&#39;
    ### Class to determine end behavior of a monoergodic Markov Chain.
    A monoergodic Markov Chain has \(1\) or more inessential states and 
    a single equivalency class.

    Refer to the base class `EndBehavior` for parameters and description 
    of what the end behavior is.
    &#39;&#39;&#39;

    def _end_state_distr(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end state distribution vector.
        Calculates what are the probabilities of
        the system to be in each state in a very large (limits to infinity) number of steps.

        Returns
        ----------
        end_state_distr : `numpy.ndarray` of shape (`chain.n_states`, )
            end state distribution vector
        &#39;&#39;&#39;

        essential_submat = self.chain.trans_mat.canonical[
            # left upper corner given the canonical numbering
            0: self.chain.n_essential_states,
            0: self.chain.n_essential_states
        ]
        essential_end_state_distr = _solve_equation_system(
            *self.equation_system(essential_submat)
        )
        end_zeros = np.zeros((self.chain.n_inessential_states))
        end_state_distr = np.concatenate((essential_end_state_distr, end_zeros), axis=0)
        return end_state_distr

    def _end_trans_mat(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end transition matrix.
        Calculates what are the probabilities of
        the transitions in a very large (limits to infinity) number of steps.

        Returns
        ----------
        end_trans_mat : `numpy.ndarray` of shape (`chain.n_states`, `chain.n_states`)
            end transition matrix
        &#39;&#39;&#39;

        end_trans_mat = self.chain._zero_mask
        end_trans_mat[:] = self.end_state_distr
        return end_trans_mat</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="marchie.end_behavior.EndBehavior" href="#marchie.end_behavior.EndBehavior">EndBehavior</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="marchie.end_behavior.EndBehavior" href="#marchie.end_behavior.EndBehavior">EndBehavior</a></b></code>:
<ul class="hlist">
<li><code><a title="marchie.end_behavior.EndBehavior.end_state_distr" href="#marchie.end_behavior.EndBehavior.end_state_distr">end_state_distr</a></code></li>
<li><code><a title="marchie.end_behavior.EndBehavior.end_trans_mat" href="#marchie.end_behavior.EndBehavior.end_trans_mat">end_trans_mat</a></code></li>
<li><code><a title="marchie.end_behavior.EndBehavior.equation_system" href="#marchie.end_behavior.EndBehavior.equation_system">equation_system</a></code></li>
<li><code><a title="marchie.end_behavior.EndBehavior.time_percentage" href="#marchie.end_behavior.EndBehavior.time_percentage">time_percentage</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="marchie.end_behavior.PolyergodicAbsorbingChainEndBehavior"><code class="flex name class">
<span>class <span class="ident">PolyergodicAbsorbingChainEndBehavior</span></span>
<span>(</span><span>chain)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="class-to-determine-end-behavior-of-a-polyergodic-absorbing-markov-chain">Class to determine end behavior of a polyergodic absorbing Markov Chain.</h3>
<p>A polyergodic absorbing Markov Chain has 1 or more inessential states and
several (2 or more) equivalency classes, each of which is absorbing.</p>
<p>Refer to the base class <code><a title="marchie.end_behavior.EndBehavior" href="#marchie.end_behavior.EndBehavior">EndBehavior</a></code> for parameters and description
of what the end behavior is.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PolyergodicAbsorbingChainEndBehavior(PolyergodicChainEndBehavior):

    &#39;&#39;&#39;
    ### Class to determine end behavior of a polyergodic absorbing Markov Chain.
    A polyergodic absorbing Markov Chain has 1 or more inessential states and 
    several (2 or more) equivalency classes, each of which is absorbing.

    Refer to the base class `EndBehavior` for parameters and description 
    of what the end behavior is.
    &#39;&#39;&#39;

    def _end_trans_mat(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end transition matrix.
        Calculates what are the probabilities of
        the transitions in a very large (limits to infinity) number of steps.

        Returns
        ----------
        end_trans_mat : `numpy.ndarray` of shape (`chain.n_states`, `chain.n_states`)
            end transition matrix
        &#39;&#39;&#39;

        # essential submatrix `T`
        end_essential_submat = np.identity(self.chain.n_essential_states)

        # inessential to essential submatrix `B`
        identity_mat = np.identity(self.chain.n_inessential_states)
        inessential_submat = self.chain.trans_mat.canonical[
            # right lower corner given the canonical numbering
            self.chain.n_essential_states: self.chain.n_states,
            self.chain.n_essential_states: self.chain.n_states
        ]
        end_inessential_submat = np.linalg.inv(identity_mat - inessential_submat)
        inessential_to_essential_submat = self.chain.trans_mat.canonical[
            # left lower corner given the canonical numbering
            self.chain.n_essential_states: self.chain.n_states,
            0: self.chain.n_essential_states
        ]
        end_inessential_to_essential_submat = np.matmul(end_inessential_submat, inessential_to_essential_submat)

        end_trans_mat = self.chain._zero_mask
        end_trans_mat[
            # left upper corner given the canonical numbering
            0: self.chain.n_essential_states,
            0: self.chain.n_essential_states
        ] = end_essential_submat
        end_trans_mat[
            # left lower corner given the canonical numbering
            self.chain.n_essential_states: self.chain.n_states,
            0: self.chain.n_essential_states
        ] = end_inessential_to_essential_submat

        return end_trans_mat</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="marchie.end_behavior.PolyergodicChainEndBehavior" href="#marchie.end_behavior.PolyergodicChainEndBehavior">PolyergodicChainEndBehavior</a></li>
<li><a title="marchie.end_behavior.EndBehavior" href="#marchie.end_behavior.EndBehavior">EndBehavior</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="marchie.end_behavior.PolyergodicChainEndBehavior" href="#marchie.end_behavior.PolyergodicChainEndBehavior">PolyergodicChainEndBehavior</a></b></code>:
<ul class="hlist">
<li><code><a title="marchie.end_behavior.PolyergodicChainEndBehavior.end_state_distr" href="#marchie.end_behavior.EndBehavior.end_state_distr">end_state_distr</a></code></li>
<li><code><a title="marchie.end_behavior.PolyergodicChainEndBehavior.end_trans_mat" href="#marchie.end_behavior.EndBehavior.end_trans_mat">end_trans_mat</a></code></li>
<li><code><a title="marchie.end_behavior.PolyergodicChainEndBehavior.equation_system" href="#marchie.end_behavior.EndBehavior.equation_system">equation_system</a></code></li>
<li><code><a title="marchie.end_behavior.PolyergodicChainEndBehavior.time_percentage" href="#marchie.end_behavior.EndBehavior.time_percentage">time_percentage</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="marchie.end_behavior.PolyergodicChainEndBehavior"><code class="flex name class">
<span>class <span class="ident">PolyergodicChainEndBehavior</span></span>
<span>(</span><span>chain)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="class-to-determine-end-behavior-of-a-polyergodic-markov-chain">Class to determine end behavior of a polyergodic Markov Chain.</h3>
<p>A polyergodic Markov Chain has <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> or more inessential states and
several ((2) or more) equivalency classes.</p>
<p>Refer to the base class <code><a title="marchie.end_behavior.EndBehavior" href="#marchie.end_behavior.EndBehavior">EndBehavior</a></code> for parameters and description
of what the end behavior is.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PolyergodicChainEndBehavior(EndBehavior):

    &#39;&#39;&#39;
    ### Class to determine end behavior of a polyergodic Markov Chain.
    A polyergodic Markov Chain has \(1\) or more inessential states and 
    several (\(2\) or more) equivalency classes.

    Refer to the base class `EndBehavior` for parameters and description 
    of what the end behavior is.
    &#39;&#39;&#39;
  
    def __init__(self, chain) -&gt; None:
        self.chain = chain
        self.end_trans_mat = self._end_trans_mat()  
        self.end_state_distr = self._end_state_distr()
        self.time_percentage = None

    def _end_state_distr(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end state distribution vector.
        Calculates what are the probabilities of
        the system to be in each state in a very large (limits to infinity) number of steps.

        Returns
        ----------
        end_state_distr : `numpy.ndarray` of shape (`chain.n_states`, )
            end state distribution vector
        &#39;&#39;&#39;

        end_state_distr = np.matmul(
            self.chain.init_distr,
            self.end_trans_mat
        )
        return end_state_distr

    def _end_trans_mat(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end transition matrix.
        Calculates what are the probabilities of
        the transitions in a very large (limits to infinity) number of steps.

        Returns
        ----------
        end_trans_mat : `numpy.ndarray` of shape (`chain.n_states`, `chain.n_states`)
            end transition matrix
        &#39;&#39;&#39;

        c = 0

        # essential submatrix `Пe`
        essential_submat = np.zeros((self.chain.n_essential_states, self.chain.n_states))
        essential_vectors = []
        for i, eq_class in enumerate(self.chain.structure.equivalency_classes):

            # transitions in each class `t` are described by its submatrix `Tt`
            begin, end = eq_class.canonical_states[0], eq_class.canonical_states[-1]
            class_mat = self.chain.trans_mat.canonical[
                begin: end + 1,
                begin: end + 1
            ]

            # each row is a vector of `π` form `(0, ..., π_, ..., 0)`,
            # `π_` is a subvector such that `π_ x Tt = π_`;
            # here we find `π_`
            class_vec = _solve_equation_system(
                *self.equation_system(class_mat)
            )
            # number of zeros on the left from `π_`
            n_zeros_left = sum([
                len(prev_eq_class) 
                for prev_eq_class in self.chain.structure.equivalency_classes[:i]
            ])
            # number of zeros on the right from `π_`
            n_zeros_right = sum([
                len(next_eq_class) 
                for next_eq_class in self.chain.structure.equivalency_classes[i + 1:]
            ]) + self.chain.n_inessential_states

            # finally `π`
            class_vec = np.concatenate((
                np.zeros((n_zeros_left)),
                class_vec,
                np.zeros((n_zeros_right))
            ), axis=0)

            # put in `Пe`; store `π`
            for _ in range(len(eq_class)): essential_submat[c] = class_vec; c += 1;
            essential_vectors.append(class_vec)


        # inessential to essential submatrix `B`
        absorbing_trans_mat = self.chain.trans_mat.canonical.copy()
        states_to_delete = []
        for eq_class in self.chain.structure.equivalency_classes:
            # leave the first state of each class
            states_to_delete += eq_class.canonical_states[1:]
            # substitute the probabilities with a single sum of them
            absorbing_trans_mat[:, eq_class.canonical_states[0]] = (absorbing_trans_mat[:, eq_class.canonical_states]).sum(axis=1)
        # delete remaining states
        absorbing_trans_mat = np.delete(absorbing_trans_mat, states_to_delete, axis=0)
        absorbing_trans_mat = np.delete(absorbing_trans_mat, states_to_delete, axis=1)

        absorbing_n_states, _ = absorbing_trans_mat.shape
        # each equivalency class we substituted with a single state,
        # which means in `absorbing_trans_mat` the number of essential states
        # equals the number of equivalency classes in the original matrix
        absorbing_identity_mat = np.identity(self.chain.n_inessential_states)
        absorbing_inessential_submat = absorbing_trans_mat[
            # right lower corner given the canonical numbering
            self.chain.n_equivalency_classes: absorbing_n_states,
            self.chain.n_equivalency_classes: absorbing_n_states
        ]
        absorbing_end_inessential_submat = np.linalg.inv(absorbing_identity_mat - absorbing_inessential_submat)
        absorbing_inessential_to_essential_submat = absorbing_trans_mat[
            # left lower corner given the canonical numbering
            self.chain.n_equivalency_classes: absorbing_n_states,
            0: self.chain.n_equivalency_classes
        ]
        end_inessential_to_essential_submat = np.matmul(
            absorbing_end_inessential_submat,
            absorbing_inessential_to_essential_submat
        )


        # inessential submatrix `Пie`
        inessential_submat = np.zeros((self.chain.n_inessential_states, self.chain.n_states))
        for i, iness_row in enumerate(inessential_submat):
            for t, ess_row in enumerate(essential_vectors):
                iness_row += end_inessential_to_essential_submat[i, t] * ess_row


        end_trans_mat = np.concatenate((essential_submat, inessential_submat), axis=0)
        return end_trans_mat

    def _time_percentage(self) -&gt; np.ndarray:

        &#39;&#39;&#39;
        ### Defines end time percentage.
        Calculates how much time the system will spend in each of the states
        during a very long (limits to infinity) period of time.
        NB! Not supported for polyergodic chains.

        Raises
        -------
        NotImplementedError
            when trying to calculate end time percentage for a polyergodic Markov Chain
        &#39;&#39;&#39;

        raise NotImplementedError(
            &#39;Percentages of time for each state are not supposed to be calculated for polyergodic chains.&#39;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="marchie.end_behavior.EndBehavior" href="#marchie.end_behavior.EndBehavior">EndBehavior</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="marchie.end_behavior.PolyergodicAbsorbingChainEndBehavior" href="#marchie.end_behavior.PolyergodicAbsorbingChainEndBehavior">PolyergodicAbsorbingChainEndBehavior</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="marchie.end_behavior.EndBehavior" href="#marchie.end_behavior.EndBehavior">EndBehavior</a></b></code>:
<ul class="hlist">
<li><code><a title="marchie.end_behavior.EndBehavior.end_state_distr" href="#marchie.end_behavior.EndBehavior.end_state_distr">end_state_distr</a></code></li>
<li><code><a title="marchie.end_behavior.EndBehavior.end_trans_mat" href="#marchie.end_behavior.EndBehavior.end_trans_mat">end_trans_mat</a></code></li>
<li><code><a title="marchie.end_behavior.EndBehavior.equation_system" href="#marchie.end_behavior.EndBehavior.equation_system">equation_system</a></code></li>
<li><code><a title="marchie.end_behavior.EndBehavior.time_percentage" href="#marchie.end_behavior.EndBehavior.time_percentage">time_percentage</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="MarChie" href="../API_reference.html">MarChie</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="marchie.end_behavior.EndBehavior" href="#marchie.end_behavior.EndBehavior">EndBehavior</a></code></h4>
<ul class="">
<li><code><a title="marchie.end_behavior.EndBehavior.end_state_distr" href="#marchie.end_behavior.EndBehavior.end_state_distr">end_state_distr</a></code></li>
<li><code><a title="marchie.end_behavior.EndBehavior.end_trans_mat" href="#marchie.end_behavior.EndBehavior.end_trans_mat">end_trans_mat</a></code></li>
<li><code><a title="marchie.end_behavior.EndBehavior.equation_system" href="#marchie.end_behavior.EndBehavior.equation_system">equation_system</a></code></li>
<li><code><a title="marchie.end_behavior.EndBehavior.time_percentage" href="#marchie.end_behavior.EndBehavior.time_percentage">time_percentage</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="marchie.end_behavior.ErgodicChainEndBehavior" href="#marchie.end_behavior.ErgodicChainEndBehavior">ErgodicChainEndBehavior</a></code></h4>
</li>
<li>
<h4><code><a title="marchie.end_behavior.MonoergodicChainEndBehavior" href="#marchie.end_behavior.MonoergodicChainEndBehavior">MonoergodicChainEndBehavior</a></code></h4>
</li>
<li>
<h4><code><a title="marchie.end_behavior.PolyergodicAbsorbingChainEndBehavior" href="#marchie.end_behavior.PolyergodicAbsorbingChainEndBehavior">PolyergodicAbsorbingChainEndBehavior</a></code></h4>
</li>
<li>
<h4><code><a title="marchie.end_behavior.PolyergodicChainEndBehavior" href="#marchie.end_behavior.PolyergodicChainEndBehavior">PolyergodicChainEndBehavior</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>